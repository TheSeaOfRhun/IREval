---
title: "EVAL"
output: html_document
---

### CODING CONVENTION
 
	NAMING
	T = Test-collection  
	M = Measure  
	Q = Query  
	S = Score
	A = Algorithm (that which is usually 'system')
 
	VARIABLE PREFIX
	v = vector
	l = list
	m = matrix
	a = array
	s = string (should be 'c' as in 'character' for R?)
	d = data frame
	w/l = wide/long table format
	f = file name (then what is a string?)

```{r}
library("reshape2")
library("ggplot2")

# Functions:

# Build the Measure x Query x Score Matrix
#  - Convert long-format table to wide-format table.
#  - Use col 1 as row names and then drop it.
#  - Create matrix from table

MQSMatrix <- function(fEval) {
    vEvalHeader = c("measure", "query", "score")
    dlMQS = read.table(fEval, header = FALSE, col.names = vEvalHeader, na.strings = c("runid", "all"))
    dlMQS = na.omit(dlMQS)
    dwMQS = dcast(dlMQS, measure ~ query, value.var = "score")
    rownames(dwMQS) = dwMQS[, 1]
    dwMQS = dwMQS[, -1]
    mMQS = data.matrix(dwMQS)
    return(mMQS)
}

# Build the Algorithm x Query x Score matrix

AQSMatrix <- function(vfEval) {
    lmEval = lapply(vfEval, function(x) MQSMatrix(x))
    lmAQS = lapply(lmEval, function(z) z["map",])
    vAName = basename(vfEval)
    vQName = names(lmAQS[[1]])
    mAQS = matrix(unlist(lmAQS), nrow = length(vfEval), byrow = T, dimnames = list(vAName, vQName))
    return(mAQS)
}

# Get list of eval files whose names match a regex.

getEvalFileList <- function(regex) {
    vfEval = list.files("data/LTR/evals", pattern = regex, full.names = TRUE)
}
```


### DEMO

The overall transformation steps:
* Read TRECEVAL output files.
* Convert each file to a MQS matrix.
* Create a list of AQS matrices, one each for a test-collection, from a set of MQS matrices.


#### Derive mMQS: Measure x Query x Score matrix

```{r}
fEval = "data/LTR/evals/AP.d.p.bm25.196.T.x"
mMQS = MQSMatrix(fEval)
print(mMQS[,1:5])

# Just for fun: plot the mMQS matrix (the plot makes no real sense).
# Rows 14, 15 and 16(num_rel, num_rel_ret, num_ret) were dropped to keep scores within a range that creates a decent picture.
mMQS = mMQS[ - c(14, 15, 16),]
 persp(x = 1:nrow(mMQS), y = 1:ncol(mMQS), z = mMQS, xlab = "Measure", ylab = "Query", zlab = "Score", theta = 30, phi = 30, col = "lightblue", shade = 0.25, ticktype = "detailed")
```

#### Derive mAQS: Algorithm x Query x Measure matrix

```{r}
vfEval = getEvalFileList("^AP\\..*")
mAQS = AQSMatrix(vfEval)
print(mAQS[,1:5])
```

#### Derive lmAQS: A list of mAQS matrices, one each for a test-collections.

```{r}
vTName = c("AP", "DOE", "FR")
lTIndex = setNames(as.list(1:length(vTName)), vTName)
vfEvalRgx = paste("^", vTName, "\\.", sep = "")
lmAQS = lapply(vfEvalRgx, function(x) {y = getEvalFileList(x); AQSMatrix(y)})

# Part of a matrix from lmAQS for the AP and DOE test-collection.
print(lmAQS[[lTIndex[["AP"]]]][, 1:5])
print(lmAQS[[lTIndex[["DOE"]]]][, 1:5])
```

#### Derive mATS: Algorithm x Test-collection x Score matrix

* Scores are Mean-scores (MAP, in this case) from each matrix in lmAQS, for all test-collections
* Followed by a plot.

```{r}

# Chris's table: Algorithm x Testcol x Mean Score
lvRowMean = lapply(vTName, function(x) rowMeans(lmAQS[[lTIndex[[x]]]]))
vColName = rownames(lmAQS[[lTIndex[[1]]]])
vAName = sapply(strsplit(vColName, "[.]"), function(x) paste(x[2:4], collapse = "."))
mATS = matrix(unlist(lvRowMean), nrow = length(vTName), byrow = T, dimnames = list(vTName, vAName))
print(mATS[, 1:5])

# Plot mATS
dATS = data.frame(mATS)
dATS[, "Algorithm"] = rownames(dATS)
dlATS = melt(dATS)
ggplot(dlATS, aes(variable, value, fill = variable)) + geom_bar(width = 0.4, stat = "identity") + facet_grid(Algorithm ~ .) + theme(strip.text.x = element_text(size = 8, angle = 90), axis.text.x = element_text(angle = 90, vjust = 0.5, size = 6))
```
